## CPU스케줄러

프로세스가 구동하려면 다양한 시스템 자원이 필요합니다. 대표적으로 CPU(중앙처리장치)와 입출력장치가 있는데, 최고의 성능을 내기 위해서 **자원을 어떤 프로세스에 얼마나 할당하는지 정책을 만드는것**을 CPU스케줄링이라고 합니다.

음식을 만들때를 예시로 말씀드리겠습니다. 찌개를 끓이기 위해서 물을 받아서 가스레인지에 올립니다. 그리고 물을 데피는 동안 각종 채소, 재료들을 손질하듯이 기다리면서 다른 일을 합니다. 이처럼 프로세스도 작업을 완료할때까지 다양한 상태가 됩니다.CPU스케쥴러에서 주목해야할 부분은 **'Waiting'**입니다.

<!-- more -->

프로세스가 CPU를 점유하여 작업을 수행하는 도중 I/O, 인터럽트(Interrupt)가 발생하면 일시적으로 프로세스는 CPU를 사용하지 않게 됩니다. **하지만 계속 점유하고 있습니다.** 이러한 상황을 줄여서, CPU를 최대한 활용하면 시스템의 성능을 개선할 수 있습니다. 결국 **"어떻게 해야 CPU의 최대한의 활용할 수 있을까"**라는 고민에서 CPU스케줄링이 시작합니다.

CPI스케줄링은 크게 두 가지로 분류됩니다. **선점(Preemptive)스케줄링**과 **비선점(Non-Preemptive)**스케줄링입니다.

### 선점 스케줄링의 특징

- CPU가 어떤 프로세스에 의해 점유중일 때, 우선 순위가 높은 프로세스가 CPU를 차지할 수 있습니다.
- 우선 순위가 높은 프로세스를 빠르게 처리해야할 경우 유용합니다.
- 선점이 일어날 경우, 오버헤드가 발생하며 처리시간을 예측하기 힘듭니다.

선점 스케줄링의 경우에는 I/O요청, I/O응답, Interrupt발생, 작업완료 등의 상황에서 스케줄링이 일어날 수 있습니다. 하지만 비선점 스케줄링의 경우 프로세스의 작업이 완료되는 시점에만 스케줄링이 일어납니다.

#### 선점스케줄링 종류

1. **SRT(Shortest Remaining Time)스케줄링**: 짧은 시간 순서대로 프로세스를 수행합니다. 남은 처리 시간이 더 짧은 프로세스가 Ready큐에 들어오면 그 프로세스가 선점됩니다.
2. **라운드로빈(Round-Robin)스케줄링**: 각 프로세스는 같은 크기의 CPU시간을 할당받고 선입선출에 의해 실행됩니다. 할당시간이 너무 크면 선입선출과 다를 바가 없어지고, 너무 작으면 오버헤드가 너무 커집니다.
3. **다단계큐(Multi-level Queue)스케줄링**: Ready큐를 여러개 사용하는 기법. 각 각의 큐는 자신의 스케줄링 알고리즘을 수행하며, 큐와 큐 사이에도 우선순위를 부여합니다.
4. **다단계 피드백 큐 스케줄링**: 다단계 큐와 비슷하나 프로세스들이 큐를 이동할 수 있습니다.

#### 비선점 스케줄링 종류

1. **HRN(Highest response ratio next)스케줄링**: 길고 짧은 작업간의 지나친 불평등을 어느 정도 보완한 기법. 수행시간의 길이와 대기 시간을 모두 고려해 우선순위를 정합니다.
2. **SJF(Shortest Job First)스케줄링**: 큐 안에 있는 프로세스 중 수행시간이 짧은 것을 먼저 수행. 평균 대기시간을 감소시킵니다.
3. 우**선순위(priority)스케줄링**: 프로세스에게 우선순위를 정적, 혹은 동적으로 부여하여 우선순위가 높은 순서대로 처리합니다. 동적으로 부여할 경우, 구현이 복잡하고 오버헤드가 많다는 단점이 있으나, 시스템의 응답속도를 증가시킵니다.
4. **기한부(Deadline) 스케줄링**: 작업을 명시된 시간이나 기한 내에 완료하도록 계획합니다.
5. **FIFO스케줄링**: 프로세스들은 Ready큐에 도착한 순서대로 CPU를 할당 받습니다. 작업 완료 시간을 예측하기에 매우 용이하지만 덜 중요한 작업이 중요한 작업을 기다리게 할 수도 있습니다.

[참고블로그](https://preamtree.tistory.com/19)

